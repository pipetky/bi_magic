'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _rsocketFlowable = require('rsocket-flowable');

var _rsocketRpcFrames = require('rsocket-rpc-frames');

var _SwitchTransformOperator = require('./SwitchTransformOperator');

var _SwitchTransformOperator2 = _interopRequireDefault(_SwitchTransformOperator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * Copyright (c) 2017-present, Netifi Inc.
                                                                                                                                                           *
                                                                                                                                                           * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                           * you may not use this file except in compliance with the License.
                                                                                                                                                           * You may obtain a copy of the License at
                                                                                                                                                           *
                                                                                                                                                           *       http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                           *
                                                                                                                                                           * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                           * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                           * See the License for the specific language governing permissions and
                                                                                                                                                           * limitations under the License.
                                                                                                                                                           *
                                                                                                                                                           * 
                                                                                                                                                           */

var RequestHandlingRSocket = function () {
  function RequestHandlingRSocket() {
    _classCallCheck(this, RequestHandlingRSocket);

    this._registeredServices = new Map();
  }

  RequestHandlingRSocket.prototype.addService = function addService(service, handler) {
    this._registeredServices.set(service, handler);
  };

  RequestHandlingRSocket.prototype.fireAndForget = function fireAndForget(payload) {
    if (payload.metadata == null) {
      throw new Error('metadata is empty');
    }

    var service = (0, _rsocketRpcFrames.getService)(payload.metadata);
    var handler = this._registeredServices.get(service);

    if (handler == null) {
      throw new Error('can not find service ' + service);
    }

    handler.fireAndForget(payload);
  };

  RequestHandlingRSocket.prototype.requestResponse = function requestResponse(payload) {
    try {
      if (payload.metadata == null) {
        return _rsocketFlowable.Single.error(new Error('metadata is empty'));
      }

      var service = (0, _rsocketRpcFrames.getService)(payload.metadata);
      var handler = this._registeredServices.get(service);

      if (handler == null) {
        return _rsocketFlowable.Single.error(new Error('can not find service ' + service));
      }

      return handler.requestResponse(payload);
    } catch (error) {
      return _rsocketFlowable.Single.error(error);
    }
  };

  RequestHandlingRSocket.prototype.requestStream = function requestStream(payload) {
    try {
      if (payload.metadata == null) {
        return _rsocketFlowable.Flowable.error(new Error('metadata is empty'));
      }

      var service = (0, _rsocketRpcFrames.getService)(payload.metadata);
      var handler = this._registeredServices.get(service);

      if (handler == null) {
        return _rsocketFlowable.Flowable.error(new Error('can not find service ' + service));
      }

      return handler.requestStream(payload);
    } catch (error) {
      return _rsocketFlowable.Flowable.error(error);
    }
  };

  RequestHandlingRSocket.prototype.requestChannel = function requestChannel(payloads) {
    var _this = this;

    return new _rsocketFlowable.Flowable(function (s) {
      return payloads.subscribe(s);
    }).lift(function (s) {
      return new _SwitchTransformOperator2.default(s, function (payload, flowable) {
        if (payload.metadata === undefined || payload.metadata === null) {
          return _rsocketFlowable.Flowable.error(new Error('metadata is empty'));
        } else {
          var service = (0, _rsocketRpcFrames.getService)(payload.metadata);
          var handler = _this._registeredServices.get(service);
          if (handler === undefined || handler === null) {
            return _rsocketFlowable.Flowable.error(new Error('can not find service ' + service));
          } else {
            return handler.requestChannel(flowable);
          }
        }
      });
    });
  };

  RequestHandlingRSocket.prototype.metadataPush = function metadataPush(payload) {
    return _rsocketFlowable.Single.error(new Error('metadataPush() is not implemented'));
  };

  return RequestHandlingRSocket;
}();

exports.default = RequestHandlingRSocket;