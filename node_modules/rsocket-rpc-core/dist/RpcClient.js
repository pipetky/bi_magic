/**
 * Copyright (c) 2017-present, Netifi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 */

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _rsocketFlowable = require('rsocket-flowable');

var _invariant = require('fbjs/lib/invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _rsocketCore = require('rsocket-core');

var _RSocketVersion = require('rsocket-core/build/RSocketVersion');

var _RSocketMachine = require('rsocket-core/build/RSocketMachine');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RpcClient = function () {
  function RpcClient(config) {
    _classCallCheck(this, RpcClient);

    this._config = config;
    this._connection = null;
  }

  RpcClient.prototype.close = function close() {
    this._config.transport.close();
  };

  RpcClient.prototype.connect = function connect() {
    var _this = this;

    (0, _invariant2.default)(!this._connection, 'RpcClient: Unexpected call to connect(), already connected.');
    this._connection = new _rsocketFlowable.Single(function (subscriber) {
      var transport = _this._config.transport;
      var subscription = void 0;
      transport.connectionStatus().subscribe({
        onNext: function onNext(status) {
          if (status.kind === 'CONNECTED') {
            subscription && subscription.cancel();
            subscriber.onComplete(new RpcSocket(_this._config, transport));
          } else if (status.kind === 'ERROR') {
            subscription && subscription.cancel();
            subscriber.onError(status.error);
          } else if (status.kind === 'CLOSED') {
            subscription && subscription.cancel();
            subscriber.onError(new Error('RpcClient: Connection closed.'));
          }
        },
        onSubscribe: function onSubscribe(_subscription) {
          subscriber.onSubscribe(function () {
            return _subscription.cancel();
          });
          subscription = _subscription;
          subscription.request(Number.MAX_SAFE_INTEGER);
        }
      });
      transport.connect();
    });
    return this._connection;
  };

  return RpcClient;
}();

/**
 * @private
 */


exports.default = RpcClient;

var RpcSocket = function () {
  function RpcSocket(config, connection) {
    _classCallCheck(this, RpcSocket);

    this._machine = (0, _RSocketMachine.createClientMachine)(connection, function (subscriber) {
      return connection.receive().subscribe(subscriber);
    }, config.serializers, config.responder);

    // Send SETUP
    connection.sendOne(this._buildSetupFrame(config));

    // Send KEEPALIVE frames
    var keepAlive = config.setup.keepAlive;

    var keepAliveFrames = (0, _rsocketFlowable.every)(keepAlive).map(function () {
      return {
        data: null,
        flags: _rsocketCore.FLAGS.RESPOND,
        lastReceivedPosition: 0,
        streamId: _rsocketCore.CONNECTION_STREAM_ID,
        type: _rsocketCore.FRAME_TYPES.KEEPALIVE
      };
    });
    connection.send(keepAliveFrames);
  }

  RpcSocket.prototype.fireAndForget = function fireAndForget(payload) {
    this._machine.fireAndForget(payload);
  };

  RpcSocket.prototype.requestResponse = function requestResponse(payload) {
    return this._machine.requestResponse(payload);
  };

  RpcSocket.prototype.requestStream = function requestStream(payload) {
    return this._machine.requestStream(payload);
  };

  RpcSocket.prototype.requestChannel = function requestChannel(payloads) {
    return this._machine.requestChannel(payloads);
  };

  RpcSocket.prototype.metadataPush = function metadataPush(payload) {
    return this._machine.metadataPush(payload);
  };

  RpcSocket.prototype.close = function close() {
    this._machine.close();
  };

  RpcSocket.prototype.connectionStatus = function connectionStatus() {
    return this._machine.connectionStatus();
  };

  RpcSocket.prototype._buildSetupFrame = function _buildSetupFrame(config) {
    var _config$setup = config.setup,
        keepAlive = _config$setup.keepAlive,
        lifetime = _config$setup.lifetime,
        metadata = _config$setup.metadata;


    return {
      flags: _rsocketCore.FLAGS.METADATA,
      keepAlive: keepAlive,
      lifetime: lifetime,
      majorVersion: _RSocketVersion.MAJOR_VERSION,
      minorVersion: _RSocketVersion.MINOR_VERSION,
      metadataMimeType: 'application/binary',
      metadata: metadata,
      dataMimeType: 'application/binary',
      data: undefined,
      resumeToken: null,
      streamId: _rsocketCore.CONNECTION_STREAM_ID,
      type: _rsocketCore.FRAME_TYPES.SETUP
    };
  };

  return RpcSocket;
}();